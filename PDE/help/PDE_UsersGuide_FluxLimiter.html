<HTML>
<HEAD>
<TITLE>PDE.UsersGuide.FluxLimiter</TITLE>
<META name="HTML-Generator" content="Dymola">
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE FluxLimiter<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="PDE.UsersGuideI.png" ALT="PDE.UsersGuide.FluxLimiter" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="PDE.UsersGuide.FluxLimiter"></A><A HREF="PDE_UsersGuide.html#PDE.UsersGuide"
>PDE.UsersGuide</A>.FluxLimiter</H2>
<PRE></pre>
<h3><font color="#008000" size=5>Flux Limiter</font></h3>
<p>

Given a hyperbolic system of <b>m</b> equations we want to solve it
with the flux limiter method. We can specify the parameter <b>m</b>
as well as the number of cell averages <br>
<b>n</b> that we wish to use in the <b>WorldModel</b> block.
The first block we need is the integrator block that will
give the <b>mxn+gcl+gcr</b> average matrix <b>Q</b> as output <br>
with which we can start the construction. Having matrix
<b>Q</b> we can compute the jumps

<p>
<img align=middle src="..\Images\ref22.png">
</p>

at each interface i = 1,...,n+gcl+gcr-1. The <b>deltaQ</b> block
achieves this task. The next step is to solve the Riemann problem

<p>
<img align=middle src="..\Images\ref23.png">
</p>

This can be accomplished by passing <b>DeltaQ</b> and <b>mxm</b>
eigenvalue matrix <b>R</b> to the <b>Riemann</b> block which will
give us the <br>
<b>mxn+gcl+gcr-1</b> matrix <b>alpha</b> as output. It is
important to note that the eigenvalue matrix <b>R</b> as well as the
eigenvalues <b>lambda<sub>i</sub></b> must be provided <br>
by the user. In the case of a constant coefficient linear hyperbolic system these do not
change with time. The next step is to use the <b>alpha</b> matrix just
obtained together <br>
with the <b>i-th</b> eigenvalue <b>lambda<sub>i</sub></b> to
calculate <b>theta<sub>i</sub></b>. The <b>theta<sub>i</sub></b> matrix has the <b>theta<sub>i</sub></b>
values in the <b>i-th</b> row and zeros elsewhere. <br>
Once <b>theta<sub>i</sub></b> matrix is computed we can use for instance <b>Beam-Warming</b> block to
compute <b>phi(theta)</b>, which is just <b>theta</b> in the Beam-Warming
method. <br>
Beam-Warming together with many other methods is implemented
in <b>FluxSolver</b> block. The user can choose which method to use
in the <b>WorldModel</b> block <br>
by giving the corresponding value to
the <b>fls</b> variable. Here is a list of methods with their
corresponding values:

<br> <br>
<pre>
<ul>
<li> <b><font color="#33CCFF" size=3>Upwind method:</font></b>          fls = 1 </li>
<li> <b><font color="#33CCFF" size=3>Lax-Wendroff method:</font></b>    fls = 2 </li>
<li> <b><font color="#33CCFF" size=3>Beam-Warming method:</font></b>    fls = 3 </li>
<li> <b><font color="#33CCFF" size=3>Fromm method:</font></b>           fls = 4 </li>
<li> <b><font color="#33CCFF" size=3>van Leer method:</font></b>        fls = 5 </li>
</ul>
</pre>

The next step is to pass the <b>alpha</b> and <b>R</b> matrix to the
<b>pWave</b> block, that will calculate the <b>p-th</b> Wave matrix

<p>
<img align=middle src="..\Images\ref24.png">
</p>

and give the <b>mxn+1</b> matrix as output. Each column <b>p</b> in
this matrix contains the wave <b>W<sub>i-1/2</sub><sup>p</sup></b>. By using the same
block but giving this time <br>
<b>widetilde{alpha}</b> as input instead of
<b>\alpha</b> we can compute the limited wave <b>widetilde{W}</b>

<p>
<img align=middle src="..\Images\ref25.png">
</p>

The limited <b>widetilde{alpha}</b> can be computed by using the block
<b>LimitedAlpha</b> which need <b>phi(theta)</b> and <b>alpha</b> matrices
as input. With the eigenvalues <br>
<b>lambda<sub>p</sub></b> and the waves matrices
<b>W</b>, <b>widetilde{W}</b> we can compute the fluxes and fluctuations.
This is done by blocks <b>FluxLimited</b> and <b>Fluctuation</b>. <br>
The <b>FluxLimited</b> block computes

<p>
<img align=middle src="..\Images\ref26.png">
</p>

If we have m equations in the system then we must use m
<b>FluxLimited</b> block to compute each term of the sum

<p>
<img align=middle src="..\Images\ref27.png">
</p>

and then sum all the outputs of the blocks and pass the result to the
<b>Flux</b> input of the integrator block. The same applies to the
<b>Fluctuation</b> block, only that here we must sum the <b>+</b> outputs <br>
of the blocks and <b>-</b> outputs of the blocks separately
and at the end pass them to the <b>+</b> and <b>-</b> inputs of the
integrator, respectively. Finally we specify the initial <br>
and boundary conditions and connect them to the <b>IC</b> and <b>gcl</b>,
<b>gcr</b> inputs, respectively.


</p>


</pre>
<p><b>Release Notes: </b></p>

<ul>
<pre></PRE><P>
<HR>
<address>HTML-documentation generated by <a href="http://www.dynasim.se/">Dymola</a> Sun Jun 17 19:58:10 2007.
</address></BODY>
</HTML>
